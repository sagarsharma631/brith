/*
  <!------------------------------------------------------------------------------------
  
    Given a value N, if we want to make change for N cents, and we have infinite supply of each of S = { S1, S2, .. , Sm} valued coins,
    how many ways can we make the change? The order of coins doesnâ€™t matter.
    
    For example, for N = 4 and S = {1,2,3}, there are four solutions: {1,1,1,1},{1,1,2},{2,2},{1,3}. So output should be 4. 
    For N = 10 and S = {2, 5, 3, 6}, there are five solutions: {2,2,2,2,2}, {2,2,3,3}, {2,2,6}, {2,3,5} and {5,5}. So the output should be 5.
 
 -----------------------------------------------------------------------------------------!>

Solution - Paradigm Used is Dynamic Programming.
*/

#include<iostream>
#define __INTEGER_MAX 0xffffffff
using namespace std;

int coinChange(){

    int arr[] = {1,5,6,8};
    int size = sizeof(arr)/sizeof(arr[0]);
    int sum = 11;

    int dpCoinChange[size][sum];
    for(int i=0;i<size;i++){
        for(int j=1;j<=sum;j++){
            if(j < arr[i]){
                if(i == 0){
                    dpCoinChange[i][j] = __INTEGER_MAX;
                }
                else{
                    dpCoinChange[i][j] = dpCoinChange[i-1][j];
                }
            }
            else if(j > arr[i]){
                if(i == 0){
                    dpCoinChange[i][j] = (j/arr[i])?(j/arr[i]):__INTEGER_MAX;
                }
                else{
                    dpCoinChange[i][j] = min(dpCoinChange[i-1][j],dpCoinChange[i][j - arr[i]] + 1);
                }
            }
            else if(j == arr[i]){
                dpCoinChange[i][j] = 1;
            }
        }
    }
    return dpCoinChange[size][sum];
}

int main(int argc, char *argv[]){
    cout<<coinChange()<<endl;
    return 0;
}
